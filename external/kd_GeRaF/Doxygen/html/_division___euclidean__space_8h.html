<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>kd-GeRaF: source/Division_Euclidean_space.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">kd-GeRaF
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">High-dimensional nearest neighbor</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Division_Euclidean_space.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;iostream&gt;</code><br />
</div>
<p><a href="_division___euclidean__space_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_division___euclidean__space.html">Division_Euclidean_space&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a645df8e39989e14bcd3e37ed5f07d10b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a645df8e39989e14bcd3e37ed5f07d10b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_division___euclidean__space_8h.html#a645df8e39989e14bcd3e37ed5f07d10b">squared_Eucl_distance</a> (std::vector&lt; T &gt; &amp;p1, std::vector&lt; T &gt; &amp;p2)</td></tr>
<tr class="memdesc:a645df8e39989e14bcd3e37ed5f07d10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance squared.  <a href="#a645df8e39989e14bcd3e37ed5f07d10b">More...</a><br /></td></tr>
<tr class="separator:a645df8e39989e14bcd3e37ed5f07d10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d0e2e72bccc1281c98aae7015d20e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65d0e2e72bccc1281c98aae7015d20e8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_division___euclidean__space_8h.html#a65d0e2e72bccc1281c98aae7015d20e8">squared_Eucl_distance</a> (const std::vector&lt; T &gt; &amp;p1, size_t start, size_t end, const std::vector&lt; T &gt; &amp;p2)</td></tr>
<tr class="memdesc:a65d0e2e72bccc1281c98aae7015d20e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance squared.  <a href="#a65d0e2e72bccc1281c98aae7015d20e8">More...</a><br /></td></tr>
<tr class="separator:a65d0e2e72bccc1281c98aae7015d20e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c5c31598ab60837945f7cca5aea1f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0c5c31598ab60837945f7cca5aea1f7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_division___euclidean__space_8h.html#ab0c5c31598ab60837945f7cca5aea1f7">squared_Eucl_distanceU</a> (const std::vector&lt; T &gt; &amp;p1, size_t start, size_t end, const std::vector&lt; T &gt; &amp;p2)</td></tr>
<tr class="memdesc:ab0c5c31598ab60837945f7cca5aea1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance squared, unroll the loop. This is specialized, avoid usage.  <a href="#ab0c5c31598ab60837945f7cca5aea1f7">More...</a><br /></td></tr>
<tr class="separator:ab0c5c31598ab60837945f7cca5aea1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e648e069ec61d903a7aeab9a906fff7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e648e069ec61d903a7aeab9a906fff7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_division___euclidean__space_8h.html#a0e648e069ec61d903a7aeab9a906fff7">squared_Eucl_distance</a> (const std::vector&lt; T &gt; &amp;p1, size_t start, size_t end, T p1_sq, const std::vector&lt; T &gt; &amp;p2, T p2_sq)</td></tr>
<tr class="memdesc:a0e648e069ec61d903a7aeab9a906fff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance squared.  <a href="#a0e648e069ec61d903a7aeab9a906fff7">More...</a><br /></td></tr>
<tr class="separator:a0e648e069ec61d903a7aeab9a906fff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a7d03b70c5067dae154d022a1df88b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a35a7d03b70c5067dae154d022a1df88b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_division___euclidean__space_8h.html#a35a7d03b70c5067dae154d022a1df88b">squared_Eucl_distance</a> (const std::vector&lt; T &gt; &amp;p, size_t start1, size_t end1, size_t start2)</td></tr>
<tr class="memdesc:a35a7d03b70c5067dae154d022a1df88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance squared.  <a href="#a35a7d03b70c5067dae154d022a1df88b">More...</a><br /></td></tr>
<tr class="separator:a35a7d03b70c5067dae154d022a1df88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869b7d808bb78a928a7a43c7cb8935d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a869b7d808bb78a928a7a43c7cb8935d5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_division___euclidean__space_8h.html#a869b7d808bb78a928a7a43c7cb8935d5">squared_Eucl_distance</a> (const std::vector&lt; T &gt; &amp;p, std::vector&lt; size_t &gt;::iterator &amp;start1, std::vector&lt; size_t &gt;::iterator end1, std::vector&lt; size_t &gt;::iterator start2)</td></tr>
<tr class="memdesc:a869b7d808bb78a928a7a43c7cb8935d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance squared.  <a href="#a869b7d808bb78a928a7a43c7cb8935d5">More...</a><br /></td></tr>
<tr class="separator:a869b7d808bb78a928a7a43c7cb8935d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac511f0e3d2cd5ea79f033c7a19764e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaac511f0e3d2cd5ea79f033c7a19764e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_division___euclidean__space_8h.html#aaac511f0e3d2cd5ea79f033c7a19764e">squared_Eucl_distance</a> (const std::vector&lt; T &gt; &amp;p, std::vector&lt; size_t &gt;::iterator &amp;start1, std::vector&lt; size_t &gt;::iterator end1, size_t index2)</td></tr>
<tr class="memdesc:aaac511f0e3d2cd5ea79f033c7a19764e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance squared.  <a href="#aaac511f0e3d2cd5ea79f033c7a19764e">More...</a><br /></td></tr>
<tr class="separator:aaac511f0e3d2cd5ea79f033c7a19764e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3419bf778fc4d72a4894572ee2802117"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3419bf778fc4d72a4894572ee2802117"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_division___euclidean__space_8h.html#a3419bf778fc4d72a4894572ee2802117">Eucl_distance</a> (const std::vector&lt; T &gt; &amp;p1, size_t start, size_t end, const std::vector&lt; T &gt; &amp;p2)</td></tr>
<tr class="memdesc:a3419bf778fc4d72a4894572ee2802117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance.  <a href="#a3419bf778fc4d72a4894572ee2802117">More...</a><br /></td></tr>
<tr class="separator:a3419bf778fc4d72a4894572ee2802117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e50a4dbc00549be03337fffc0c59464"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e50a4dbc00549be03337fffc0c59464"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_division___euclidean__space_8h.html#a1e50a4dbc00549be03337fffc0c59464">computeSquare</a> (const std::vector&lt; T &gt; &amp;p, const size_t N, const size_t D, std::vector&lt; T &gt; &amp;squared_coords)</td></tr>
<tr class="memdesc:a1e50a4dbc00549be03337fffc0c59464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and store the sum of squared coordinates per point.  <a href="#a1e50a4dbc00549be03337fffc0c59464">More...</a><br /></td></tr>
<tr class="separator:a1e50a4dbc00549be03337fffc0c59464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d03c94f0990b1f9193158b9380ed45"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a01d03c94f0990b1f9193158b9380ed45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_division___euclidean__space_8h.html#a01d03c94f0990b1f9193158b9380ed45">computeSquare</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;p, const size_t N, const size_t D, std::vector&lt; T &gt; &amp;squared_coords)</td></tr>
<tr class="memdesc:a01d03c94f0990b1f9193158b9380ed45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and store the sum of squared coordinates per point. Here, the input vector is 2D.  <a href="#a01d03c94f0990b1f9193158b9380ed45">More...</a><br /></td></tr>
<tr class="separator:a01d03c94f0990b1f9193158b9380ed45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A space that allows us to split the data. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1e50a4dbc00549be03337fffc0c59464"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void computeSquare </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>squared_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute and store the sum of squared coordinates per point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- input vector of points </td></tr>
    <tr><td class="paramname">N</td><td>- number of points </td></tr>
    <tr><td class="paramname">D</td><td>- dimension </td></tr>
    <tr><td class="paramname">squared_coords</td><td>- output vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01d03c94f0990b1f9193158b9380ed45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void computeSquare </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>squared_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute and store the sum of squared coordinates per point. Here, the input vector is 2D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- input vector of points </td></tr>
    <tr><td class="paramname">N</td><td>- number of points </td></tr>
    <tr><td class="paramname">D</td><td>- dimension </td></tr>
    <tr><td class="paramname">squared_coords</td><td>- output vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3419bf778fc4d72a4894572ee2802117"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Eucl_distance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>- first point </td></tr>
    <tr><td class="paramname">start</td><td>- starting index of first point </td></tr>
    <tr><td class="paramname">end</td><td>- ending index of first point </td></tr>
    <tr><td class="paramname">p2</td><td>- second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- the Euclidean distance </dd></dl>

</div>
</div>
<a class="anchor" id="a645df8e39989e14bcd3e37ed5f07d10b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T squared_Eucl_distance </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance squared. </p>
<p>Faster to compute than Euclidean distance and enough for comparison. Parameters are vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>- first point </td></tr>
    <tr><td class="paramname">p2</td><td>- second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- the Euclidean distance of p1-p2 </dd></dl>

</div>
</div>
<a class="anchor" id="a65d0e2e72bccc1281c98aae7015d20e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T squared_Eucl_distance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance squared. </p>
<p>Faster to compute than Euclidean distance and enough for comparison. Parameters are vectors. First vector is a collection of points, thus we need its start and end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>- first point </td></tr>
    <tr><td class="paramname">start</td><td>- starting index of first point </td></tr>
    <tr><td class="paramname">end</td><td>- ending index of first point </td></tr>
    <tr><td class="paramname">p2</td><td>- second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- the Euclidean distance of p1-p2 </dd></dl>

</div>
</div>
<a class="anchor" id="a0e648e069ec61d903a7aeab9a906fff7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T squared_Eucl_distance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>p1_sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>p2_sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance squared. </p>
<p>Faster to compute than Euclidean distance and enough for comparison. Parameters are vectors. We need to compute only the dot product.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>- first point </td></tr>
    <tr><td class="paramname">start</td><td>- starting index of first point </td></tr>
    <tr><td class="paramname">end</td><td>- ending index of first point </td></tr>
    <tr><td class="paramname">p1_sq</td><td>- squared first point </td></tr>
    <tr><td class="paramname">p2</td><td>- second point </td></tr>
    <tr><td class="paramname">p2_sq</td><td>- squared second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- the Euclidean distance of p1-p2 </dd></dl>

</div>
</div>
<a class="anchor" id="a35a7d03b70c5067dae154d022a1df88b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T squared_Eucl_distance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance squared. </p>
<p>Faster to compute than Euclidean distance and enough for comparison.</p>
<p>We pass a vector of points, where both points lie into, thus we need the start and the end of of the first point and the start of the second one, since points should be of same dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- vector of points </td></tr>
    <tr><td class="paramname">start1</td><td>- starting index of first point </td></tr>
    <tr><td class="paramname">end1</td><td>- ending index of first point </td></tr>
    <tr><td class="paramname">start2</td><td>- starting index of second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- the Euclidean distance of p1-p2 </dd></dl>

</div>
</div>
<a class="anchor" id="a869b7d808bb78a928a7a43c7cb8935d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T squared_Eucl_distance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt;::iterator &amp;&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt;::iterator&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt;::iterator&#160;</td>
          <td class="paramname"><em>start2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance squared. </p>
<p>Faster to compute than Euclidean distance and enough for comparison. Parameters are iterators.</p>
<p>We pass a vector of points, where both points lie into, thus we need the start and the end of of the first point and the start of the second one, since points should be of same dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- vector of points </td></tr>
    <tr><td class="paramname">start1</td><td>- starting of first point </td></tr>
    <tr><td class="paramname">end1</td><td>- ending of first point </td></tr>
    <tr><td class="paramname">start2</td><td>- starting of second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- the Euclidean distance of p1-p2 </dd></dl>

</div>
</div>
<a class="anchor" id="aaac511f0e3d2cd5ea79f033c7a19764e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T squared_Eucl_distance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt;::iterator &amp;&#160;</td>
          <td class="paramname"><em>start1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt;::iterator&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance squared. </p>
<p>Faster to compute than Euclidean distance and enough for comparison. Parameters are iterators for the first point and index for the second one.</p>
<p>We pass a vector of points, where both points lie into, thus we need the start and the end of of the first point and the index of the second one, since points should be of same dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>- vector of points </td></tr>
    <tr><td class="paramname">start1</td><td>- starting of first point </td></tr>
    <tr><td class="paramname">end1</td><td>- ending of first point </td></tr>
    <tr><td class="paramname">index2</td><td>- index of second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- the Euclidean distance of p1-p2 </dd></dl>

</div>
</div>
<a class="anchor" id="ab0c5c31598ab60837945f7cca5aea1f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T squared_Eucl_distanceU </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance squared, unroll the loop. This is specialized, avoid usage. </p>
<p>Faster to compute than Euclidean distance and enough for comparison. Parameters are vectors. First vector is a collection of points, thus we need its start and end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>- first point </td></tr>
    <tr><td class="paramname">start</td><td>- starting index of first point </td></tr>
    <tr><td class="paramname">end</td><td>- ending index of first point </td></tr>
    <tr><td class="paramname">p2</td><td>- second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- the Euclidean distance of p1-p2 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 26 2015 16:24:23 for kd-GeRaF by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
