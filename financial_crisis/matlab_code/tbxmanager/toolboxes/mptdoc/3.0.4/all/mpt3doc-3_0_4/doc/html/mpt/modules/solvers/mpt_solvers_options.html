<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>mpt_solvers_options</title>
<style type="text/css">
	body {background-color: white; color: black; font-family:sans-serif; font-size:medium;}
	a:link {color: #3300ff;}
	a:visited {color: #663399;}
	a:hover {color:#0099ff;}
	a:active {color: #0066cc;}
	a.button {text-decoration:none;}
	
	table.nav  {background-color: #dbddff;}
	table.body {margin-top:2ex; margin-bottom:2ex;}
	table.programlistingindent {margin-left:32px;}
	
	img { margin-bottom:0px; margin-top:0px;}
	tt {margin-left:0.5em; margin-right:0.5em; font-weight:lighter;}
	
	p {margin-top:0ex;}
	p.synopsis {margin-left:32px;}
	p.programlistingindent {margin-left:32px;}
	p.citetitle {margin-left:2em;}
	
	ul ul {list-style-type:square;}
	ul li p {margin-top:0ex; margin-bottom:.5ex; padding:0}
	ol li p {margin-top:0ex; margin-bottom:.5ex; padding:0}
	
	h1.reftitle {color:#a90000;}
	h1.reftitle {font-size:3.7ex; margin-top:0; margin-bottom:0; font-weight:bold}
	h1.title {color:black; font-size:4ex; margin-top:1ex; font-weight:bold}
	h2.title {color:#bd0000; margin-top:1ex; margin-bottom:.9ex; font-weight:bold; font-size:3ex}
	h3.title {color:#bd0000; margin-top:1ex; margin-bottom:.9ex; font-weight:bold; font-size:2.5ex}
	h4.title {color:#bd0000; margin-top:1ex; margin-bottom:.9ex; font-weight:bold; font-size:2ex}
	h2 {color:#bd0000; margin-top:1ex; margin-bottom:.9ex; font-weight:bold; font-size:2.5ex}
	h3 {color:#bd0000; margin-top:1ex; margin-bottom:.9ex; font-weight:bold; font-size:2ex} 
	
	pre.programlisting {margin-left:32px;}
	pre.synopsis {margin-left:32px;}
	
	
	.categorytitle {margin-top:8px; padding-top:0px;}
	.categorylist {background-color: #e1e6f2;}
 	</style>
</head>
<body>
<a name="top_of_page"></a><p style="font-size:1px;"></p>
<h1 class="reftitle">mpt_solvers_options</h1>
<h2>Purpose</h2>
<p>Global option settings for solvers.</p>
<h2>Syntax</h2>
<pre class="synopsis">s = mpt_solvers_options</pre>
<h2>Description</h2>
<p></p>
		This function returns a structure with default option settings for 
        solvers used in MPT. 
        
        Used by <tt>mptopt</tt> class by first time initialization of MPT.
        Later these settings are changed via <tt>mptopt</tt> class.
        
	<h2>Output Arguments</h2>
<table cellspacing="0" class="body" cellpadding="4" border="0" width="100%">
<colgroup>
<col width="31%">
<col width="69%">
</colgroup>
<tbody><tr valign="top">
<td><tt>s</tt></td>
<td>
<p></p>options structure<p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.clp</tt></td>
<td>
<p></p>settings for CLP solver<p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.clp.solver</tt></td>
<td>
<p></p>Which method to choose for solving LP/QP.<p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>1</tt><p></p>primal</li>
<li>
<tt>2</tt><p></p>dual</li>
</ul></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.clp.maxnumiterations</tt></td>
<td>
<p></p>Maximum number of iterations allowed <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 99999999</p>
</td>
</tr><tr valign="top">
<td><tt>s.clp.maxnumseconds</tt></td>
<td>
<p></p>Maximum time allowed for computation in seconds<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 3600</p>
</td>
</tr><tr valign="top">
<td><tt>s.clp.primaltolerance</tt></td>
<td>
<p></p>Tolerance on the primal solution.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-7</p>
</td>
</tr><tr valign="top">
<td><tt>s.clp.dualtolerance</tt></td>
<td>
<p></p>Tolerance on the dual solution.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-7</p>
</td>
</tr><tr valign="top">
<td><tt>s.clp.primalpivot</tt></td>
<td>
<p></p>Which pivot method to choose for primal solution.<p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>1</tt><p></p>steepest</li>
<li>
<tt>2</tt><p></p>Dantzig</li>
</ul></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.clp.dualpivot</tt></td>
<td>
<p></p>Which pivot method to choose for dual solution.<p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>1</tt><p></p>steepest</li>
<li>
<tt>2</tt><p></p>Dantzig</li>
</ul></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.clp.verbose</tt></td>
<td>
<p></p>Verbosity level.<p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>silent</li>
<li>
<tt>1</tt><p></p>verbose</li>
<li>
<tt>2</tt><p></p>loud</li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><p></p></p>
</td>
</tr><tr valign="top">
<td><tt>s.cplexint</tt></td>
<td>
<p></p>Settings for CPLEX solver interfaced by Automatic Control Laboratory (cplexint).<p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.cplexint.verbose</tt></td>
<td>
<p></p>Verbosity level. <p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>silent</li>
<li>
<tt>1</tt><p></p>verbose</li>
<li>
<tt>2</tt><p></p>loud</li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.cplexint.logfile</tt></td>
<td>
<p></p>Redirect output to a file.<p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.cplexint.lic_rel</tt></td>
<td>
<p></p>After how many runs to release the license.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e3</p>
</td>
</tr><p></p></p>
</td>
</tr><tr valign="top">
<td><tt>s.cplex</tt></td>
<td>
<p></p>Settings for CPLEX solver interfaced by IBM.<p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.cplex.lpmethod</tt></td>
<td>
<p></p>Which method to use for solving LP.<p>
	    		Class: <tt>char</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>automatic</li>
<li>
<tt>1</tt><p></p>primal simplex</li>
<li>
<tt>2</tt><p></p>dual simplex</li>
<li>
<tt>3</tt><p></p>network simplex</li>
<li>
<tt>4</tt><p></p>barrier</li>
<li>
<tt>5</tt><p></p>sifting</li>
<li>
<tt>6</tt><p></p>concurrent</li>
</ul></p>
<p>
	    		Default: 2</p>
</td>
</tr><tr valign="top">
<td><tt>s.cplex.qpmethod</tt></td>
<td>
<p></p>Which method to use for solving QP.<p>
	    		Class: <tt>char</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>automatic</li>
<li>
<tt>1</tt><p></p>primal simplex</li>
<li>
<tt>2</tt><p></p>dual simplex</li>
<li>
<tt>3</tt><p></p>network simplex</li>
<li>
<tt>4</tt><p></p>barrier</li>
<li>
<tt>5</tt><p></p>sifting</li>
<li>
<tt>6</tt><p></p>concurrent</li>
</ul></p>
<p>
	    		Default: 2</p>
</td>
</tr><p></p></p>
</td>
</tr><tr valign="top">
<td><tt>s.plcp</tt></td>
<td>
<p></p>settings for PLCP solver<p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.plcp.bfs</tt></td>
<td>
<p></p>Perform breadth first search when explorting the parameter space.<p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.plcp.dfs</tt></td>
<td>
<p></p>Perform breadth first search when explorting the parameter space.<p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.plcp.debug</tt></td>
<td>
<p></p>Debugging level<p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>no debugging</li>
<li>
<tt>1</tt><p></p>no plots</li>
<li>
<tt>2</tt><p></p>including plots</li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.plcp.fixedstep</tt></td>
<td>
<p></p>Always perform a step over the facet with a fixed step size given as <tt>region_tol</tt>.
                        An alternative way to detect regions while exploring the parameter space. The approach is useful
                        when numerical problems occurs with the standard method where the step size is computed automatically.
                        <p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.plcp.QRfactor</tt></td>
<td>
<p></p>Inside the main pivoting funtion use recursive QR factorization instead of direct LU factorization.
                            It will speed up the computation time but will suffer from numerical problems for large LCP problems.
                        <p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.plcp.checkoverlaps</tt></td>
<td>
<p></p>Check for overlaps while exploring the parameter space. This option enforces to search through all
                        discovered regions at each step for overlaps. If the overlap is detected, the overlapping part is discarted 
                        via set-difference operation. Since this requires solving an LP for each region, this option reduces the 
                        computational time significantly.
                        <p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.plcp.rescue</tt></td>
<td>
<p></p>If the variable step approach fails to find adjacent region, retry with the fixed step.
                        The step size is given as the Chebyshev radius of the smallest allowable region, i.e. half of 
                        the <tt>region_tol</tt>.                        
                        <p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.plcp.maxsteps</tt></td>
<td>
<p></p>Maximum number of steps to perform with the fixed step approach in case no new regions
                        have been found. Minimum 2-steps must be provided.
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 200</p>
</td>
</tr><tr valign="top">
<td><tt>s.plcp.maxlayers</tt></td>
<td>
<p></p>Maximum value of layers to be explored for breadth first search (BFS). This option is valid only with
                    BFS option. Useful only if there are too many regions far from the initial region that can be discarded from 
                            optimal solution. The layered list of regions is returned in the field <tt>layer_list</tt>.
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: Inf</p>
</td>
</tr><tr valign="top">
<td><tt>s.plcp.maxregions</tt></td>
<td>
<p></p>Maximum number of regions to be generated. 
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: Inf</p>
</td>
</tr><tr valign="top">
<td><tt>s.plcp.maxpivots</tt></td>
<td>
<p></p>The maximum number of pivots to be performed to find a neighboring region. Typically, the are  
                        1, 2 pivots to be performed to find a neighboring regions. For a degenerate case, more pivots are needed.
                            The maximum value of the pivots is given by the <tt>RecursionLimit</tt> of MATLAB which 500 by default.
                            If the value of maxpivots is greater than <tt>RecursionLimit</tt>, change also this value by
                            <tt>set(0,'RecursionLimit',N)</tt>.
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 100</p>
</td>
</tr><tr valign="top">
<td><tt>s.plcp.adjcheck</tt></td>
<td>
<p></p>Force verification of the adjacency list in the postprocessing phase. This option activates 
                        a subfunction in the PLCP solver where the adjacency list is checked for any missing links in the graph 
                        and performs correction. The option is turned off by default because the verification can be time
                        consuming for large partitions.
                        <p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><p></p></p>
</td>
</tr><tr valign="top">
<td><tt>s.lcp</tt></td>
<td>
<p></p>settings for LCP solver<p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.lcp.zerotol</tt></td>
<td>
<p></p>Less than this treshold the value is considered as zero.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-10</p>
</td>
</tr><tr valign="top">
<td><tt>s.lcp.lextol</tt></td>
<td>
<p></p>Lexicographic tolerance - a small treshold from which values are considered as equal. <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-9</p>
</td>
</tr><tr valign="top">
<td><tt>s.lcp.nstepf</tt></td>
<td>
<p></p> If <tt>options.routine</tt> is 0, then every <tt>nstepf</tt> pivot steps the basis is refactorized to
                        avoid numerical problems for LUMOD. For other routines the factorization
                        is performed at each step.
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 50</p>
</td>
</tr><tr valign="top">
<td><tt>s.lcp.maxpiv</tt></td>
<td>
<p></p>Maximum number of pivots to be performed. <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e4</p>
</td>
</tr><tr valign="top">
<td><tt>s.lcp.clock</tt></td>
<td>
<p></p>Show the information about the computational time.<p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.lcp.verbose</tt></td>
<td>
<p></p>Verbose output.<p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.lcp.routine</tt></td>
<td>
<p></p>Routine which should be used to obtain a basis solution. <p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>Corresponds to LUmod package that performs factorization in the form
                                <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options1.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options1.png">. Depending on the change in <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options2.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options2.png"> factors <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options3.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options3.png">, <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options4.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options4.png">  are updated. 
                                This is the fastest method.
                                </li>
<li>
<tt>1</tt><p></p>Corresponds to DGESV simple driver from LAPACK package which solves
                                the system <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options5.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options5.png"> by factorizing <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options6.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options6.png"> and overwriting <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options7.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options7.png"> with the solution <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options8.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options8.png">.
                                Since the factorization is performed at each pivot step, this method
                                tends to be much slower than method 0.
                            </li>
<li>
<tt>2</tt><p></p>
                                Corresponds to DGELS simple driver which solves overdetermined or
                                underdetermined real linear systems <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options9.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options9.png"> involving an 
                                <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options10.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options10.png">-by-<img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options11.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options11.png"> matrix <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options12.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options12.png">, or its transpose, using a QR or LQ factorization of
                                <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options13.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options13.png">. Since the factorization is performed at each pivot step, this
                                method tends to be much slower than method 0.                                                    
                            </li>
</ul></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.lcp.timelimit</tt></td>
<td>
<p></p>Time limit in seconds. If this limit is exceeded, the pivoting algorithm
                         is terminated and current basis is returned.  <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 3600</p>
</td>
</tr><tr valign="top">
<td><tt>s.lcp.normalize</tt></td>
<td>
<p></p> Input matrices <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options14.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options14.png">, <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options15.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options15.png">  get scaled by <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options16.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options16.png"> and <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options17.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options17.png"> when invoking this
                                 option: <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options18.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options18.png">, <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options19.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options19.png">, and solution is recovered as <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options20.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options20.png">, <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options21.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options21.png">.   
                            <p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.lcp.normalizethres</tt></td>
<td>
<p></p> If the <tt>normalize</tt> option is on, then the matrix scaling is performed 
                                 only if 1 norm of matrix <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options22.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options22.png"> (maximum absolute column sum) is above this
                                threshold. 
                            <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e6</p>
</td>
</tr><p></p></p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk</tt></td>
<td>
<p></p>settings for GLPK solver<p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.glpk.msglev</tt></td>
<td>
<p></p>Level of messages output by solver routines.<p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>No output.</li>
<li>
<tt>1</tt><p></p>Error messages only.</li>
<li>
<tt>2</tt><p></p>Normal output.</li>
<li>
<tt>3</tt><p></p>Full output (includes informational messages).</li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.lpsolver</tt></td>
<td>
<p></p>Which method to choose for solving primal LP.<p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>1</tt><p></p>Revised simplex method.</li>
<li>
<tt>2</tt><p></p>Interior point method.</li>
<li>
<tt>3</tt><p></p>Simplex method with exact arithmetic.</li>
</ul></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.scale</tt></td>
<td>
<p></p>Which method of scaling to use.<p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>No scaling.</li>
<li>
<tt>1</tt><p></p>Equilibration scaling.</li>
<li>
<tt>2</tt><p></p>Geometric mean scaling, then equilibration scaling.</li>
<li>
<tt>3</tt><p></p>Geometric then Equilibrium scaling.</li>
<li>
<tt>4</tt><p></p>Round to nearest power of 2 scaling.</li>
</ul></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.dual</tt></td>
<td>
<p></p>Which method to choose for solving dual LP.<p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>Do not use the dual simplex.</li>
<li>
<tt>1</tt><p></p>If initial basic solution is dual feasible, use the dual simplex.</li>
<li>
<tt>2</tt><p></p>Use two phase dual simplex, or if primal simplex if dual fails.</li>
</ul></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.price</tt></td>
<td>
<p></p>Pricing option (for both primal and dual simplex).<p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>Textbook pricing.</li>
<li>
<tt>1</tt><p></p>Steepest edge pricing.</li>
</ul></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.r_test</tt></td>
<td>
<p></p>Ratio test technique.<p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>Standart (textbook).</li>
<li>
<tt>1</tt><p></p>Harris's two-pass ratio test.</li>
</ul></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.relax</tt></td>
<td>
<p></p>Relaxation parameter used in the ratio test.
                            If it is zero, the textbook ratio test is used. If it is non-zero (should be
                            positive), Harris two-pass ratio test is used. In the latter case on the
                            first pass of the ratio test basic variables (in the case of primal
                            simplex) or reduced costs of non-basic variables (in the case of dual
                            simplex) are allowed to slightly violate their bounds, but not more than
                            <tt>relax*tolbnd</tt> or <tt>relax*toldj</tt> 
                            (thus, <tt>relax</tt> is a percentage of <tt>tolbnd</tt> or <tt>toldj</tt>).                    
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 0.07</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.tolbnd</tt></td>
<td>
<p></p>Relative tolerance used to check ifthe current basic
                            solution is primal feasible. It is not recommended that you change this
                            parameter unless you have a detailed understanding of its purpose. 
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-7</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.toldj</tt></td>
<td>
<p></p>Absolute tolerance used to check if the current basic
                               solution is dual feasible. It is not recommended that you change this
                               parameter unless you have a detailed understanding of its purpose. 
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-7</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.tolpiv</tt></td>
<td>
<p></p>Relative tolerance used to choose eligible pivotal
                              elements of the simplex table. It is not recommended that you change this
                              parameter unless you have a detailed understanding of its purpose.
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-9</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.round</tt></td>
<td>
<p></p>Solution rounding option.
                        <p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>Report all primal and dual values "as is" (default).</li>
<li>
<tt>1</tt><p></p>Replace tiny primal and dual values by exact zero.</li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.objll</tt></td>
<td>
<p></p>Lower limit of the
                             objective function. If on the phase II the objective
                             function reaches this limit and continues decreasing, the
                             solver stops the search. This parameter is used in the
                             dual simplex method only.                            
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: -1e12</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.objul</tt></td>
<td>
<p></p>Upper limit of the
                             objective function. If on the phase II the objective
                             function reaches this limit and continues increasing,
                             the solver stops the search. This parameter is used in
                             the dual simplex only.                         
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e12</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.itlim</tt></td>
<td>
<p></p>Simplex iterations limit.
                             If this value is positive, it is decreased by one each
                             time when one simplex iteration has been performed, and
                             reaching zero value signals the solver to stop the search.
                             Negative value means no iterations limit.                         
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e4</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.itcnt</tt></td>
<td>
<p></p>Output frequency, in iterations.
                         This parameter specifies how frequently the solver sends
                         information about the solution to the standard output.                      
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 200</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.usecuts</tt></td>
<td>
<p></p>
                     <tt>glp_intopt</tt> generates and adds cutting planes to
                         the MIP problem in order to improve its LP relaxation
                         before applying the branch-and-bound method.<p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>All cuts off.</li>
<li>
<tt>1</tt><p></p>Gomoy's mixed integer cuts.</li>
<li>
<tt>2</tt><p></p>Mixed integer rounding cuts.</li>
<li>
<tt>3</tt><p></p>Mixed cover cuts.</li>
<li>
<tt>4</tt><p></p>Clique cuts.</li>
<li>
<tt>5</tt><p></p>All cuts.</li>
</ul></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.pprocess</tt></td>
<td>
<p></p>
                             Pre-processing technique option (for MIP only).
                        <p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>Disable preprocessing.</li>
<li>
<tt>1</tt><p></p>Perform preprocessing for root only.</li>
<li>
<tt>2</tt><p></p>Perform preprocessing for all levels.</li>
</ul></p>
<p>
	    		Default: 2</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.binarize</tt></td>
<td>
<p></p>
                             Binarizeation option (for MIP), used only if presolver is enabled.
                        <p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>Do not use binarization.</li>
<li>
<tt>1</tt><p></p>Replace general integer variables by binary ones.</li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.tmlim</tt></td>
<td>
<p></p>
                             Searching time limit, in
                             seconds. If this value is positive, it is decreased each
                             time when one simplex iteration has been performed by the
                             amount of time spent for the iteration, and reaching zero
                             value signals the solver to stop the search. Negative
                             value means no time limit
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: -1</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.branch</tt></td>
<td>
<p></p>
                             Branching heuristic option (for MIP only).
                        <p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>Branch on the first variable.</li>
<li>
<tt>1</tt><p></p>Branch on the last variable.</li>
<li>
<tt>2</tt><p></p>Branch on the most fractional variable.</li>
<li>
<tt>3</tt><p></p>Branch using a heuristic by Driebeck and Tomlin.</li>
</ul></p>
<p>
	    		Default: 2</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.btrack</tt></td>
<td>
<p></p>
                             Backtracking heuristic option (for MIP only).
                        <p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>Depth first search.</li>
<li>
<tt>1</tt><p></p>Breadth first search.</li>
<li>
<tt>2</tt><p></p>Best local bound.</li>
<li>
<tt>3</tt><p></p>Backtrack using the best projection heuristic.</li>
</ul></p>
<p>
	    		Default: 2</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.tolint</tt></td>
<td>
<p></p>
                             Relative tolerance used
                             to check if the current basic solution is integer
                             feasible. It is not recommended that you change this
                             parameter unless you have a detailed understanding of
                             its purpose.
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-6</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.outdly</tt></td>
<td>
<p></p>
                         Output delay, in seconds.
                         This parameter specifies how long the solver should
                         delay sending information about the solution to the standard
                         output. Non-positive value means no delay.
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.tolobj</tt></td>
<td>
<p></p>
                             Relative tolerance used
                             to check if the value of the objective function is not
                             better than in the best known integer feasible solution.
                             It is not recommended that you change this parameter
                             unless you have a detailed understanding of its purpose.
                       <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-7</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.presol</tt></td>
<td>
<p></p>
                             If this flag is set, the routine
                             <tt>lpx_simplex</tt> solves the problem using the built-in LP presolver.
                             Otherwise the LP presolver is not used.
                       <p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.save</tt></td>
<td>
<p></p>
                              If this parameter is nonzero save a copy of
                              the original problem to file.
                       <p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.glpk.mipgap</tt></td>
<td>
<p></p>
                             The relative mip gap tolerance.  
                             If the relative mip gap for currently known best integer feasible
                             solution falls below this tolerance, the solver terminates
                             the search.  This allows obtaining suboptimal interger
                             feasible solutions if solving the problem to optimality
                             takes too long.
                       <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 0</p>
</td>
</tr><p></p></p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi</tt></td>
<td>
<p></p>settings for GUROBI solver<p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.gurobi.BarIterLimit</tt></td>
<td>
<p></p>Limits the number of barrier iterations performed (barrier only).<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e12</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.CutOff</tt></td>
<td>
<p></p> If the objective value for the optimal solution is better than the specified cutoff,
                        the solver will return the optimal solution. Otherwise, it will terminate with a CUTOFF status.
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e12</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.IterationLimit</tt></td>
<td>
<p></p>Limits the number of simplex iterations performed.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e6</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.NodeLimit</tt></td>
<td>
<p></p>Limits the number of MIP nodes explored (MIP only).<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e12</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.SolutionLimit</tt></td>
<td>
<p></p>Limits the number of feasible solutions found (MIP only).<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e12</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.TimeLimit</tt></td>
<td>
<p></p>Limits the total time expended (in seconds).<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e12</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.BarConvTol</tt></td>
<td>
<p></p>Barrier convergence tolerance (barrier only). The barrier solver
                                terminates when the relative difference between the primal and dual
                                objective values is less than the specified tolerance.
                                Value must be in range [1e-10, 1].
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-8</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.BarConvTol</tt></td>
<td>
<p></p>Barrier convergence tolerance (barrier only). The barrier solver
                                terminates when the relative difference between the primal and dual
                                objective values is less than the specified tolerance.
                                Value must be in range [1e-10, 1].
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-8</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.BarQCPConvTol</tt></td>
<td>
<p></p>The barrier solver terminates when the relative difference between the
                            primal and dual objective values is less than the specified tolerance.
                            ightening this tolerance may lead to a more accurate solution, but it may 
                            also lead to a failure to converge. 
                            Values must be in range [0, 1];
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-6</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.FeasibilityTol</tt></td>
<td>
<p></p> All constraints must be satisfied to a tolerance of <tt>FeasibilityTol</tt>.
                            Tightening this tolerance can produce smaller constraint violations, 
                            but for numerically challenging models it can sometimes lead to much larger iteration counts.
                            Value must be in range [1e-9, 1e-2].
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-6</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.IntFeasTol</tt></td>
<td>
<p></p> Integer feasibility tolerance (MIP only). An integrality restriction on a
                                variable is considered satisfied when the variable's value is less than
                                <tt>INTFEASTOL</tt> from the nearest integer value.   
                                Value must be in range [1e-9, 1e-1].
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-5</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.OptimalityTol</tt></td>
<td>
<p></p> Dual feasibility tolerance. Reduced costs must all be smaller than
                                 OptimalityTol in the improving direction in order for a model to be
                                 declared optimal.
                                Value must be in range [1e-9, 1e-2].
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-6</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.MIPGap</tt></td>
<td>
<p></p> Relative MIP optimality gap (MIP only). The MIP engine will terminate
                             (with an optimal result) when the gap between the lower and upper
                              objective bound is less than MIPGap times the upper bound.  
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-4</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.PSDTol</tt></td>
<td>
<p></p> Positive semi-definite tolerance (QP/MIQP only). Sets a limit on the
                                 amount of diagonal perturbation that the optimizer is allowed to perform
                                 on the Q matrix in order to correct minor PSD violations. If a larger
                                 perturbation is required, the optimizer will terminate with an
                                 <tt>GRB_ERROR_Q_NOT_PSD</tt> error.
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-6</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.InfUnbdInfo</tt></td>
<td>
<p></p>Determines whether simplex (and crossover) will compute
                        additional information when a model is determined to be infeasible or
                        unbounded. Set this parameter if you want to query the unbounded ray for
                        unbounded models (through the UnbdRay attribute), or the infeasibility
                        proof for infeasible models (through the FarkasDual and FarkasProof
                        attributes).
                        <p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.NormAdjust</tt></td>
<td>
<p></p> Chooses from among multiple pricing norm variants. The details of
                        how this parameter affects the simplex pricing algorithm are subtle and
                        difficult to describe, so we've simply labeled the options 0 through 3.
                        The default value of -1 chooses automatically.
                        Changing the value of this parameter rarely produces a significant benefit. 
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: -1</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.PerturbValue</tt></td>
<td>
<p></p> Magnitude of the simplex perturbation. Note that
                        perturbation is only applied when progress has stalled, so the parameter
                         will often have no effect. Values must be in range [0, 0.01].
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 0.0002</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.ScaleFlag</tt></td>
<td>
<p></p>Enables or disables model scaling. Scaling usually
                        improves the numerical properties of the model, which typically leads to
                        reduced solution times, but it may sometimes lead to larger constraint
                        violations in the original, unscaled model.   
                        <p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.ObjScale</tt></td>
<td>
<p></p>  Divides the model objective by the specified value to avoid
                             numerical errors that may result from very large objective coefficients.
                             The default value of 0 decides on the scaling automatically. A value less
                             than zero uses the maximum coefficient to the specified power as the
                             scaling (so <tt>ObjScale=-0.5</tt> would scale by the square root of the largest
                             objective coefficient).
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.BarCorrectors</tt></td>
<td>
<p></p>  Limits the number of central corrections performed in each barrier iteration.
                        The default value chooses automatically, depending on problem characteristics. 
                        The automatic strategy generally works well, although it is often possible to obtain
                        higher performance on a specific model by selecting a value manually. The values must 
                        be in range [-1, Inf)
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: -1</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.Method</tt></td>
<td>
<p></p>  Algorithm used to solve continuous models or the root node of a MIP model.
                        Concurrent optimizers run multiple solvers on multiple threads simultaneously, and choose the one
                        that finishes first. Deterministic concurrent (Method=4) gives the exact same result each time, 
                        while Method=3 is often faster but can produce different optimal bases when run multiple times. 
                        In the current release, the default Automatic (Method=-1) will typically choose non-deterministic concurrent
                        (Method=3) for an LP, barrier (Method=2) for a QP or QCP, and dual (Method=1) for the MIP root node.
                        Only simplex and barrier algorithms are available for continuous QP models. Only primal and dual
                        simplex are available for solving the root of an MIQP model. Only barrier is available for
                        continuous QCP models.

                        The default setting is rarely significantly slower than the best possible setting, so you
                        generally won't see a big gain from changing this parameter. There are classes of models where
                        one particular algorithm is consistently fastest, though, so you may want to experiment with
                        different options when confronted with a particularly difficult model.

                        Note that if memory is tight on an LP model, you should consider choosing the dual
                        simplex method (Method=1). The default will invoke the concurrent optimizer, which typically
                        consumes a lot more memory than dual simplex alone. 
                        <p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>-1</tt><p></p>automatic</li>
<li>
<tt>0</tt><p></p>primal simplex</li>
<li>
<tt>1</tt><p></p>dual simplex</li>
<li>
<tt>2</tt><p></p>barrier</li>
<li>
<tt>3</tt><p></p>concurrent</li>
<li>
<tt>4</tt><p></p>deterministic concurrent</li>
</ul></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.Presolve</tt></td>
<td>
<p></p> Controls the presolve level. A value of -1 corresponds to an automatic
                                setting.
                        <p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>-1</tt><p></p>Automatic</li>
<li>
<tt>0</tt><p></p>Off</li>
<li>
<tt>1</tt><p></p>Conservative</li>
<li>
<tt>2</tt><p></p>Aggressive</li>
</ul></p>
<p>
	    		Default: -1</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.TimeLimit</tt></td>
<td>
<p></p>  Limits the total time expended (in seconds).
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e12</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.Threads</tt></td>
<td>
<p></p>  Controls the number of threads to apply to parallel MIP. The default
                                 value of 0 sets the thread count equal to the maximum value, which is the
                                 number of processors in the machine.
                                 Value should range from 0 to maximum number of processors.
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.OutputFlag</tt></td>
<td>
<p></p>  Verbosity level.
                        <p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.gurobi.DisplayInterval</tt></td>
<td>
<p></p> Controls the frequency at which log lines are printed (in seconds).
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 5</p>
</td>
</tr><p></p></p>
</td>
</tr><tr valign="top">
<td><tt>s.nag</tt></td>
<td>
<p></p>settings for NAG solver<p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.nag.qp</tt></td>
<td>
<p></p>settings for QP solver <p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.nag.qp.ftol</tt></td>
<td>
<p></p>The maximum acceptable violation in each constraint at a "feasible" point.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-9</p>
</td>
</tr><tr valign="top">
<td><tt>s.nag.qp.rank_tol</tt></td>
<td>
<p></p>Enables the user to control the condition number of the triangular factor <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options23.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options23.png">.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-20</p>
</td>
</tr><tr valign="top">
<td><tt>s.nag.qp.crash_tol</tt></td>
<td>
<p></p>A constraint of the form <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options24.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options24.png"> will be included in the initial
                                        working set if <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options25.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options25.png">.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 0.1</p>
</td>
</tr><tr valign="top">
<td><tt>s.nag.qp.reset_ftol</tt></td>
<td>
<p></p>This option is part of an anti-cycling procedure designed to guarantee
                                        progress even on highly degenerate problems.
                                    <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 5</p>
</td>
</tr><tr valign="top">
<td><tt>s.nag.qp.max_iter</tt></td>
<td>
<p></p>maximum number of iterations to be performed
                                    <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e6</p>
</td>
</tr><tr valign="top">
<td><tt>s.nag.qp.fcheck</tt></td>
<td>
<p></p>every fcheck iterations, a numerical test is
                                        made to see if the current solution satisfies
                                        the constraints in the working set
                                    <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 50</p>
</td>
</tr><tr valign="top">
<td><tt>s.nag.qp.inf_bound</tt></td>
<td>
<p></p>defines the "infinite" bound in the definition
                                        of the problem constraints
                                    <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e12</p>
</td>
</tr><p></p></p>
</td>
</tr><tr valign="top">
<td><tt>s.nag.lp</tt></td>
<td>
<p></p>settings for LP solver <p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.nag.lp.ftol</tt></td>
<td>
<p></p>The maximum acceptable violation in each constraint at a "feasible" point.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-9</p>
</td>
</tr><tr valign="top">
<td><tt>s.nag.lp.optim_tol</tt></td>
<td>
<p></p>Enables the user to control the condition number of the triangular factor <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options26.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options26.png">.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-13</p>
</td>
</tr><tr valign="top">
<td><tt>s.nag.lp.crash_tol</tt></td>
<td>
<p></p>A constraint of the form <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options27.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options27.png"> will be included in the initial
                                    working set if <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options28.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options28.png">.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 0.1</p>
</td>
</tr><tr valign="top">
<td><tt>s.nag.lp.reset_ftol</tt></td>
<td>
<p></p>This option is part of an anti-cycling procedure designed to guarantee
                                     progress even on highly degenerate problems.
                                    <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 5</p>
</td>
</tr><tr valign="top">
<td><tt>s.nag.lp.max_iter</tt></td>
<td>
<p></p>maximum number of iterations to be performed
                                    <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e6</p>
</td>
</tr><tr valign="top">
<td><tt>s.nag.lp.fcheck</tt></td>
<td>
<p></p>every fcheck iterations, a numerical test is
                                     made to see if the current solution satisfies
                                     the constraints in the working set
                                    <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 50</p>
</td>
</tr><tr valign="top">
<td><tt>s.nag.lp.inf_bound</tt></td>
<td>
<p></p>defines the "infinite" bound in the definition
                                        of the problem constraints
                                    <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e12</p>
</td>
</tr><p></p></p>
</td>
</tr><p></p></p>
</td>
</tr><tr valign="top">
<td><tt>s.qpip</tt></td>
<td>
<p></p>settings for QPC interior point solver "qpip"<p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.qpip.mu</tt></td>
<td>
<p></p>Desired complementarity gap target (point on central-path).<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.qpip.method</tt></td>
<td>
<p></p>If <tt>method=1</tt>, then a faster but less accurate linear
                                solve step is used. Conversely, if <tt>method=0</tt> then a slower but
                                more accurate linear solve step is used.
                            <p>
	    		Class: <tt>logical</tt></p>
<p>
	    		Default: 0</p>
</td>
</tr><p></p></p>
</td>
</tr><tr valign="top">
<td><tt>s.qpspline</tt></td>
<td>
<p></p>settings for QPspline solver<p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.qpspline.maxiter</tt></td>
<td>
<p></p>The maximum number of iterations. <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 10000</p>
</td>
</tr><tr valign="top">
<td><tt>s.qpspline.abs_tol</tt></td>
<td>
<p></p>Absolute tolerance.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-8</p>
</td>
</tr><tr valign="top">
<td><tt>s.qpspline.nstepf</tt></td>
<td>
<p></p>After these <tt>nstepf</tt> steps the basis will be refactored with new <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options29.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options29.png">, <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options30.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options30.png">, factors.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 30</p>
</td>
</tr><tr valign="top">
<td><tt>s.qpspline.nqrelems</tt></td>
<td>
<p></p> Do recursive QR factorization if the number of changed elements
                             (rows/cols) is less than this treshold. If the treshold is large, the
                             recursive factorization may actually consume more time than direct
                             factorization. Large treshold causes also accumulation of numerical
                             errors.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 20</p>
</td>
</tr><tr valign="top">
<td><tt>s.qpspline.timelimit</tt></td>
<td>
<p></p> 
                            Time limit on the computations in seconds.
                        <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 3600</p>
</td>
</tr><tr valign="top">
<td><tt>s.qpspline.verbose</tt></td>
<td>
<p></p> 
                            Show the iteration progress.
                        <p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><p></p></p>
</td>
</tr><tr valign="top">
<td><tt>s.quadprog</tt></td>
<td>
<p></p>settings for QUADPROG solver<p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.quadprog.MaxIter</tt></td>
<td>
<p></p>Maximum number of iterations allowed.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e6</p>
</td>
</tr><tr valign="top">
<td><tt>s.quadprog.TolFun</tt></td>
<td>
<p></p>Termination tolerance on the function value.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-10</p>
</td>
</tr><tr valign="top">
<td><tt>s.quadprog.TolX</tt></td>
<td>
<p></p>Termination tolerance on the solution.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-10</p>
</td>
</tr><tr valign="top">
<td><tt>s.quadprog.Display</tt></td>
<td>
<p></p>Display progress of optimization.<p>
	    		Class: <tt>char</tt><p>Allowed values:</p><ul>
<li><tt>notify</tt></li>
<li><tt>iter</tt></li>
<li><tt>final</tt></li>
</ul></p>
<p>
	    		Default: off</p>
</td>
</tr><tr valign="top">
<td><tt>s.quadprog.Algorithm</tt></td>
<td>
<p></p>Algorithm for solving the QP<p>
	    		Class: <tt>char</tt><p>Allowed values:</p><ul>
<li><tt>active-set</tt></li>
<li><tt>interior-point</tt></li>
<li><tt>interior-point-convex</tt></li>
<li><tt>levenberg-marquardt</tt></li>
<li><tt>sqp</tt></li>
<li><tt>trust-region-dogleg</tt></li>
<li><tt>trust-region-reflective</tt></li>
</ul></p>
<p>
	    		Default: active-set</p>
</td>
</tr><tr valign="top">
<td><tt>s.quadprog.LargeScale</tt></td>
<td>
<p></p>Use large-scale or medium-scale algorithms.<p>
	    		Class: <tt>char</tt><p>Allowed values:</p><ul>
<li><tt>on</tt></li>
<li><tt>off</tt></li>
</ul></p>
<p>
	    		Default: off</p>
</td>
</tr><p></p></p>
</td>
</tr><tr valign="top">
<td><tt>s.linprog</tt></td>
<td>
<p></p>settings for LINPROG solver<p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.linprog.MaxIter</tt></td>
<td>
<p></p>Maximum number of iterations allowed.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e6</p>
</td>
</tr><tr valign="top">
<td><tt>s.linprog.TolFun</tt></td>
<td>
<p></p>Termination tolerance on the function value.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-10</p>
</td>
</tr><tr valign="top">
<td><tt>s.linprog.TolX</tt></td>
<td>
<p></p>Termination tolerance on the solution.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-10</p>
</td>
</tr><tr valign="top">
<td><tt>s.linprog.Display</tt></td>
<td>
<p></p>Display progress of optimization.<p>
	    		Class: <tt>char</tt><p>Allowed values:</p><ul>
<li><tt>notify</tt></li>
<li><tt>iter</tt></li>
<li><tt>final</tt></li>
</ul></p>
<p>
	    		Default: off</p>
</td>
</tr><p></p></p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi</tt></td>
<td>
<p></p>settings for SEDUMI solver<p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.sedumi.fid</tt></td>
<td>
<p></p>Verbosity level<p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>silent</li>
<li>
<tt>1</tt><p></p>loud</li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.alg</tt></td>
<td>
<p></p> Type of algorithm that solves the problem.
                        <p>
	    		Class: <tt>double</tt><p>Allowed values:</p><ul>
<li>
<tt>0</tt><p></p>The first-order wide region algorithm is used, not recommended. </li>
<li>
<tt>1</tt><p></p>The centering-predictor-corrector algorithm is used with v-linearization.</li>
<li>
<tt>2</tt><p></p>The xz-linearization is used in the corrector, similar to Mehrotra's algorithm.</li>
</ul></p>
<p>
	    		Default: 2</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.theta</tt></td>
<td>
<p></p>The wide region parameter which varies <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options31.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options31.png">.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 0.25</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.beta</tt></td>
<td>
<p></p>The neighborhood region parameter which varies <img src="../../../../fig/mpt/modules/solvers/mpt_solvers_options32.png" alt="../../../../fig/mpt/modules/solvers/mpt_solvers_options32.png">.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 0.5</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.stepdif</tt></td>
<td>
<p></p>Set primal/dual differentiation step length.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 2</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.w</tt></td>
<td>
<p></p>The weights for the relative primal, dual and gap residuals as
                         w(1):w(2):1 in order to find the optimal step differentiation.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: [1 1]</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.eps</tt></td>
<td>
<p></p>The desired accuracy.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-10</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.bigeps</tt></td>
<td>
<p></p>In case the desired accuracy cannot be achieved, SEDUMI tries to satisfy this accuracy.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-6</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.maxiter</tt></td>
<td>
<p></p>Maximum iterations allowed.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e6</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.cg</tt></td>
<td>
<p></p>Settings for preconditioned conjugate gradient method (CG),
                        which is only used if results from Cholesky are inaccurate.<p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.sedumi.cg.maxiter</tt></td>
<td>
<p></p>Maximum number of CG-iterates (per solve). Theoretically needed
                                is <tt>|add|+2*|skip|</tt>, the number of added and skipped pivots in Cholesky.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 49</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.cg.restol</tt></td>
<td>
<p></p>Terminates if residual is a <tt>restol</tt> fraction of duality gap.
                                 Should be smaller than 1 in order to make progress.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 5e-3</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.cg.refine</tt></td>
<td>
<p></p>Number of refinement loops that are allowed. The maximum number
                                    of actual CG-steps will thus be <tt>1+(1+refine)*maxiter</tt>. 
                                <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.cg.stagtol</tt></td>
<td>
<p></p>Terminates if relative function progress less than stagtol.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 4e-14</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.cg.qprec</tt></td>
<td>
<p></p>Stores cg-iterates in quadruple precision if true.<p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><p></p></p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.chol</tt></td>
<td>
<p></p>Parameters for controling the Cholesky solve.
                        <p>
	    		Class: <tt>struct</tt><p></p><tr valign="top">
<td><tt>s.sedumi.chol.canceltol</tt></td>
<td>
<p></p>Relative tolerance for detecting cancelation during Cholesky.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-12</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.chol.maxu</tt></td>
<td>
<p></p>Adds to diagonal if <tt>max(abs(L(:,j))) &gt; maxu</tt> otherwise.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 5e5</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.chol.abstol</tt></td>
<td>
<p></p>Skips pivots falling below <tt>abstol</tt>.
                                <p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 1e-20</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.chol.maxuden</tt></td>
<td>
<p></p>Pivots in dense-column factorization so that these factors
                                satisfy <tt>max(abs(Lk)) &lt;= maxuden</tt>.<p>
	    		Class: <tt>double</tt></p>
<p>
	    		Default: 5e2</p>
</td>
</tr><tr valign="top">
<td><tt>s.sedumi.chol.errors</tt></td>
<td>
<p></p>If this field is true then SEDUMI outputs some error
                                       measures as defined in the Seventh DIMACS Challenge. <p>
	    		Class: <tt>logical</tt><p>Allowed values:</p><ul>
<li><tt>0</tt></li>
<li><tt>1</tt></li>
</ul></p>
<p>
	    		Default: 0</p>
</td>
</tr><p></p></p>
</td>
</tr><p></p></p>
</td>
</tr><p></p></p>
</td>
</tr></tbody>
</table>
<h2>References</h2>
<p class="citetitle">[1] 
	Stephen Boyd and Lieven Vandenberghe: Convex Optimization; Cambridge University Press
</p>
<h2>See Also</h2>
<a href="../../mptopt.html">mptopt</a>, <a href="./mpt_solve.html">mpt_solve</a><p></p>
<table class="nav" summary="Navigation aid" border="0" width="100%" cellpadding="0" cellspacing="0"><tr valign="top">
<td align="left" width="20">
<a href="mpt_call_qpc.html" class="button">&#9664;</a>  </td>
<td align="left">mpt_call_qpc</td>
<td>  </td>
<td align="right">mpt_call_cplex</td>
<td align="right" width="20"><a href="mpt_call_cplex.html" class="button">&#9654;</a></td>
</tr></table>
<br><p>  <b>2010-2013</b>     Martin Herceg: ETH Zurich,    <a href="mailto:herceg@control.ee.ethz.ch">herceg@control.ee.ethz.ch</a></p>
</body>
</html>
